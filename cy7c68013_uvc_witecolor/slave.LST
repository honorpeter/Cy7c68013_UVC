C51 COMPILER V8.08   SLAVE                                                                 07/25/2020 11:39:40 PAGE 1   


C51 COMPILER V8.08, COMPILATION OF MODULE SLAVE
OBJECT MODULE PLACED IN slave.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE slave.c OPTIMIZE(6,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #pragma NOIV                    // Do not generate interrupt vectors
   2          //-----------------------------------------------------------------------------
   3          //   File:      slave.c
   4          //   Contents:  Hooks required to implement USB peripheral function.
   5          //              Code written for FX2 REVE 56-pin and above.
   6          //              This firmware is used to demonstrate FX2 Slave FIF
   7          //              operation.
   8          //   Copyright (c) 2003 Cypress Semiconductor All rights reserved
   9          //-----------------------------------------------------------------------------
  10          #include "fx2.h"
  11          #include "fx2regs.h"
  12          #include "fx2sdly.h"            // SYNCDELAY macro
  13          
  14          #define LED_ALL         (bmBIT0 | bmBIT1 | bmBIT2 | bmBIT3)
  15          
  16          extern BOOL GotSUD;             // Received setup data flag
  17          extern BOOL Sleep;
  18          extern BOOL Rwuen;
  19          extern BOOL Selfpwr;
  20          
  21          BYTE Configuration;             // Current configuration
  22          BYTE AlternateSetting;          // Alternate settings
  23          static WORD xdata LED_Count = 0;
  24          static BYTE xdata LED_Status = 0;
  25          BOOL done_frm_fpga = 0;
  26          
  27          // EZUSB FX2 PORTA = slave fifo enable(s), when IFCFG[1:0]=11
  28          //sbit PA0 = IOA ^ 0;             // alt. func., INT0#
  29          //sbit PA1 = IOA ^ 1;             // alt. func., INT1#
  30          // sbit PA2 = IOA ^ 2;          // is SLOE
  31          //sbit PA3 = IOA ^ 3;             // alt. func., WU2
  32          // sbit PA4 = IOA ^ 4;          // is FIFOADR0
  33          // sbit PA5 = IOA ^ 5;          // is FIFOADR1
  34          // sbit PA6 = IOA ^ 6;          // is PKTEND
  35          // sbit PA7 = IOA ^ 7;          // is FLAGD
  36          
  37          // EZUSB FX2 PORTC i/o...       port NA for 56-pin FX2
  38          // sbit PC0 = IOC ^ 0;
  39          // sbit PC1 = IOC ^ 1;
  40          // sbit PC2 = IOC ^ 2;
  41          // sbit PC3 = IOC ^ 3;
  42          // sbit PC4 = IOC ^ 4;
  43          // sbit PC5 = IOC ^ 5;
  44          // sbit PC6 = IOC ^ 6;
  45          // sbit PC7 = IOC ^ 7;
  46          
  47          // EZUSB FX2 PORTB = FD[7:0], when IFCFG[1:0]=11
  48          // sbit PB0 = IOB ^ 0;
  49          // sbit PB1 = IOB ^ 1;
  50          // sbit PB2 = IOB ^ 2;
  51          // sbit PB3 = IOB ^ 3;
  52          // sbit PB4 = IOB ^ 4;
  53          // sbit PB5 = IOB ^ 5;
  54          // sbit PB6 = IOB ^ 6;
  55          // sbit PB7 = IOB ^ 7;
C51 COMPILER V8.08   SLAVE                                                                 07/25/2020 11:39:40 PAGE 2   

  56          
  57          // EZUSB FX2 PORTD = FD[15:8], when IFCFG[1:0]=11 and WORDWIDE=1
  58          //sbit PD0 = IOD ^ 0;
  59          //sbit PD1 = IOD ^ 1;
  60          //sbit PD2 = IOD ^ 2;
  61          //sbit PD3 = IOD ^ 3;
  62          //sbit PD4 = IOD ^ 4;
  63          //sbit PD5 = IOD ^ 5;
  64          //sbit PD6 = IOD ^ 6;
  65          //sbit PD7 = IOD ^ 7;
  66          
  67          // EZUSB FX2 PORTE is not bit-addressable...
  68          
  69          //-----------------------------------------------------------------------------
  70          // Task Dispatcher hooks
  71          // The following hooks are called by the task dispatcher.
  72          //-----------------------------------------------------------------------------
  73          //void LED_Off (BYTE LED_Mask);
  74          //void LED_On (BYTE LED_Mask);
  75          
  76          //-----------------------------------------------------------------------------
  77          // Task Dispatcher hooks
  78          //   The following hooks are called by the task dispatcher.
  79          //-----------------------------------------------------------------------------
  80          void TD_Init(void)             // Called once at startup
  81          {
  82   1         // set the CPU clock to 48MHz
  83   1              CPUCS = 0x12;   //48MHZ  CLKOUT ENALBE
  84   1      
  85   1         // set the slave FIFO interface to 48MHz
  86   1         IFCONFIG |= 0x40;
  87   1      //   IFCONFIG = 0X03; //选择为外部时钟，且为同步slaveFIFO模式，输入IFCLK:5~48MHz
  88   1      
  89   1        // Registers which require a synchronization delay, see section 15.14
  90   1        // FIFORESET        FIFOPINPOLAR
  91   1        // INPKTEND         OUTPKTEND
  92   1        // EPxBCH:L         REVCTL
  93   1        // GPIFTCB3         GPIFTCB2
  94   1        // GPIFTCB1         GPIFTCB0
  95   1        // EPxFIFOPFH:L     EPxAUTOINLENH:L
  96   1        // EPxFIFOCFG       EPxGPIFFLGSEL
  97   1        // PINFLAGSxx       EPxFIFOIRQ
  98   1        // EPxFIFOIE        GPIFIRQ
  99   1        // GPIFIE           GPIFADRH:L
 100   1        // UDMACRCH:L       EPxGPIFTRIG
 101   1        // GPIFTRIG
 102   1        
 103   1        // Note: The pre-REVE EPxGPIFTCH/L register are affected, as well...
 104   1        //      ...these have been replaced by GPIFTC[B3:B0] registers
 105   1      
 106   1        // default: all endpoints have their VALID bit set
 107   1        // default: TYPE1 = 1 and TYPE0 = 0 --> BULK  
 108   1        // default: EP2 and EP4 DIR bits are 0 (OUT direction)
 109   1        // default: EP6 and EP8 DIR bits are 1 (IN direction)
 110   1        // default: EP2, EP4, EP6, and EP8 are double buffered
 111   1      
 112   1        // we are just using the default values, yes this is not necessary...
 113   1        SYNCDELAY;        // see TRM section 15.14
 114   1        EP2CFG = 0xE0;        // enabled, quad buffered, 512B, IN, bulk fifo, 4 buffer
 115   1      //      EP2CFG = 0xE8;  // enabled, quad buffered, 1024B, IN, bulk fifo, 4 buffer
 116   1        SYNCDELAY;                    
 117   1        EP4CFG = 0x00;        // disabled...
C51 COMPILER V8.08   SLAVE                                                                 07/25/2020 11:39:40 PAGE 3   

 118   1        SYNCDELAY;                    
 119   1        EP6CFG = 0x00;        // disabled...
 120   1        SYNCDELAY;                    
 121   1        EP8CFG = 0x00;        // disabled...
 122   1      
 123   1        // out endpoints do not come up armed
 124   1        
 125   1        // since the defaults are double buffered we must write dummy byte counts twice
 126   1      //  SYNCDELAY;                    
 127   1      //  EP2BCL = 0x80;                // arm EP2OUT by writing byte count w/skip.
 128   1      //  SYNCDELAY;                    
 129   1      //  EP2BCL = 0x80;
 130   1      //  SYNCDELAY;                    
 131   1      //  EP4BCL = 0x80;                // arm EP4OUT by writing byte count w/skip.
 132   1      //  SYNCDELAY;                    
 133   1      //  EP4BCL = 0x80;    
 134   1      
 135   1      // Configure the EPxFIFOCFG
 136   1              EP2FIFOCFG = 0x00;      // autoin, 8 Bit Wide
 137   1      //      EP2FIFOCFG = 0x09;      // autoin, 16 Bit Wide
 138   1              SYNCDELAY;              
 139   1              EP4FIFOCFG = 0x00;      // no-autoOUT, bytewide
 140   1              SYNCDELAY;                     
 141   1              EP6FIFOCFG = 0x00;      // no-autoOUT, bytewide
 142   1              SYNCDELAY;                     
 143   1              EP8FIFOCFG = 0x00;      // no-autoOUT, bytewide
 144   1              SYNCDELAY;    
 145   1      
 146   1      // Configure PIN Polarity
 147   1              PORTACFG |= 0x40;       //IFCOG[1:0] = 11(Slave FIFO Mode), Set PORTACFG[6] to USE PA7-SLCS
 148   1              SYNCDELAY;      
 149   1              FIFOPINPOLAR = 0x00;//BIT[5:0] = {PKTEND, SLOE, SLRD, SLWR, EMPTY, FULL}
 150   1                                                      //Set SLWR, PKTEND, SLOE,SLRD EMPTY, FULL Low Active
 151   1              SYNCDELAY;
 152   1      
 153   1      // Configure Autoin package Length
 154   1      //      EP2AUTOINLENH = 0x02; // EZ-USB automatically commits data in 512-byte chunks
 155   1      //      EP2AUTOINLENH = 0x04; // EZ-USB automatically commits data in 1024-byte chunks
 156   1      //      SYNCDELAY;
 157   1      //      EP2AUTOINLENL = 0x00;
 158   1      //      SYNCDELAY;      
 159   1              
 160   1      // FLAGA - User-Programmable Level; FLAGB - FIFO Full, FLAGC - FIFO Empty: (L: Valid)
 161   1              PINFLAGSAB = 0x00;//0x8a;
 162   1              SYNCDELAY;  
 163   1              PINFLAGSCD = 0x00;//0x08;
 164   1              SYNCDELAY;
 165   1      
 166   1      // Reset FIFO, then clear endpoint
 167   1              SYNCDELAY;
 168   1              FIFORESET = 0x80;// activate NAK-ALL to avoid race conditions
 169   1              SYNCDELAY;
 170   1              FIFORESET = 0x02;// reset, FIFO 2
 171   1              SYNCDELAY;
 172   1              FIFORESET = 0x04;// reset, FIFO 4
 173   1              SYNCDELAY;
 174   1              FIFORESET = 0x06;// reset, FIFO 6
 175   1              SYNCDELAY;
 176   1          FIFORESET = 0x08;// reset, FIFO 8
 177   1              SYNCDELAY;
 178   1              FIFORESET = 0x00;// deactivate NAK-AL
 179   1              SYNCDELAY;
C51 COMPILER V8.08   SLAVE                                                                 07/25/2020 11:39:40 PAGE 4   

 180   1      
 181   1      // enable dual autopointer feature
 182   1         // AUTOPTRSETUP |= 0x01;
 183   1      
 184   1         USBIE |= bmSOF;
 185   1         SYNCDELAY;
 186   1         //Configure Start Trigger
 187   1         OED |= (1<<2);       //PD2   0:Input;        1:output
 188   1         PD2 = 0;
 189   1        
 190   1      
 191   1      }
 192          
 193          unsigned char BCH=0x8c;
 194          unsigned short wn_33ms=0;
 195          void TD_Poll( void )
 196          { // Called repeatedly while the device is idle
 197   1      static unsigned long wn=0;
 198   1      static unsigned long nan=4;
 199   1      static BOOL      flag=0;
 200   1      unsigned short i=0;
 201   1      
 202   1      if(wn<0x0000ffff0)
 203   1      {wn++;}
 204   1      else
 205   1      {
 206   2      //PD2=1;
 207   2      
 208   2      if(0)//(wn_33ms!=160)
 209   2      {}
 210   2      else{
 211   3      while( !( EP24FIFOFLGS & 0x02 ) )
 212   3       { // EP8EF=0, when buffer not empty
 213   4       ; // wait ‘til host takes entire FIFO data
 214   4       }
 215   3       
 216   3      
 217   3      //if(nan==4)
 218   3      //{
 219   3      flag=~flag;
 220   3      //nan=0;
 221   3      
 222   3      EP2FIFOBUF[0]=0x0c;//   0c 8d 9c e1  85 20 64 99  ac 20 03 06
 223   3      
 224   3      
 225   3              EP2FIFOBUF[1]=BCH;
 226   3              if(0)//(flag)
 227   3              {}
 228   3              else 
 229   3              {
 230   4              
 231   4               /* Modify UVC header to toggle Frame ID */
 232   4                      BCH ^= 0x01;
 233   4              
 234   4                      /* Indicate End of Frame in the buffer */
 235   4       //EP2FIFOBUF[1] |=  0x02;
 236   4              }
 237   3              EP2FIFOBUF[2]=nan;
 238   3              EP2FIFOBUF[3]=0x12;
 239   3              EP2FIFOBUF[4]=0x12;
 240   3              EP2FIFOBUF[5]=0x12;
 241   3              EP2FIFOBUF[6]=(unsigned char)(nan&0x000000ff);;                    
C51 COMPILER V8.08   SLAVE                                                                 07/25/2020 11:39:40 PAGE 5   

 242   3              EP2FIFOBUF[7]=(unsigned char)((nan>>8)&0x000000ff);
 243   3              EP2FIFOBUF[8]=(unsigned char)((nan>>16)&0x000000ff);
 244   3              EP2FIFOBUF[9]=(unsigned char)((nan>>24)&0x000000ff);
 245   3              EP2FIFOBUF[10]=0xc1;
 246   3              EP2FIFOBUF[11]=0x05;
 247   3      //      EP2FIFOBUF[12]++;
 248   3      //}
 249   3         SYNCDELAY;
 250   3      for(i=6;i<512/2;i++)
 251   3      {
 252   4      // if(EP2FIFOBUF[i]>100){EP2FIFOBUF[i]=EP2FIFOBUF[i]%128;}      
 253   4      // if(EP2FIFOBUF[i]<20){EP2FIFOBUF[i]=EP2FIFOBUF[i]+20;}
 254   4        EP2FIFOBUF[2*i]=0xf4;
 255   4        EP2FIFOBUF[2*i+1]=0x80;
 256   4      
 257   4       // EP2FIFOBUF[3*i+2]=0x80;
 258   4      }
 259   3      
 260   3      
 261   3      
 262   3       nan++;
 263   3        SYNCDELAY;
 264   3              EP2BCH = 0x01;
 265   3               SYNCDELAY;
 266   3                              EP2BCL = 0x2c;//0xbc; // Clear bytecount to allow new data in; also stops NAKing
 267   3                               SYNCDELAY;
 268   3                       INPKTEND=0x02;
 269   3        
 270   3      
 271   3      }
 272   2      }
 273   1      
 274   1      }
 275          
 276          BOOL TD_Suspend( void )          
 277          { // Called before the device goes into suspend mode
 278   1         return( TRUE );
 279   1      }
 280          
 281          BOOL TD_Resume( void )          
 282          { // Called after the device resumes
 283   1         return( TRUE );
 284   1      }
 285          
 286          //-----------------------------------------------------------------------------
 287          // Device Request hooks
 288          //   The following hooks are called by the end point 0 device request parser.
 289          //-----------------------------------------------------------------------------
 290          BOOL DR_GetDescriptor( void )
 291          {
 292   1         return( TRUE );
 293   1      }
 294          
 295          BOOL DR_SetConfiguration( void )   
 296          { // Called when a Set Configuration command is received
 297   1        
 298   1        if( EZUSB_HIGHSPEED( ) )
 299   1        { // ...FX2 in high speed mode
 300   2      
 301   2              EP2AUTOINLENH = 0x02;   // set core AUTO commit len = 512 bytes
 302   2          SYNCDELAY;
 303   2              EP2AUTOINLENL = 0x00;
C51 COMPILER V8.08   SLAVE                                                                 07/25/2020 11:39:40 PAGE 6   

 304   2      
 305   2        }
 306   1        else
 307   1        { // ...FX2 in full speed mode
 308   2          EP6AUTOINLENH = 0x00;
 309   2          SYNCDELAY;
 310   2          EP8AUTOINLENH = 0x00;   // set core AUTO commit len = 64 bytes
 311   2          SYNCDELAY;
 312   2          EP6AUTOINLENL = 0x40;
 313   2          SYNCDELAY;
 314   2          EP8AUTOINLENL = 0x40;
 315   2        }
 316   1            
 317   1        Configuration = SETUPDAT[ 2 ];
 318   1        return( TRUE );        // Handled by user code
 319   1      }
 320          
 321          BOOL DR_GetConfiguration( void )   
 322          { // Called when a Get Configuration command is received
 323   1         EP0BUF[ 0 ] = Configuration;
 324   1         EP0BCH = 0;
 325   1         EP0BCL = 1;
 326   1         return(TRUE);          // Handled by user code
 327   1      }
 328          
 329          BOOL DR_SetInterface( void )       
 330          { // Called when a Set Interface command is received
 331   1         AlternateSetting = SETUPDAT[ 2 ];
 332   1         return( TRUE );        // Handled by user code
 333   1      }
 334          
 335          BOOL DR_GetInterface( void )       
 336          { // Called when a Set Interface command is received
 337   1         EP0BUF[ 0 ] = AlternateSetting;
 338   1         EP0BCH = 0;
 339   1         EP0BCL = 1;
 340   1         return( TRUE );        // Handled by user code
 341   1      }
 342          
 343          BOOL DR_GetStatus( void )
 344          {
 345   1         return( TRUE );
 346   1      }
 347          
 348          BOOL DR_ClearFeature( void )
 349          {
 350   1         return( TRUE );
 351   1      }
 352          
 353          BOOL DR_SetFeature( void )
 354          {
 355   1         return( TRUE );
 356   1      }
 357          
 358          BOOL DR_VendorCmnd( void )
 359          {
 360   1        return( TRUE );
 361   1      }
 362          
 363          //-----------------------------------------------------------------------------
 364          // USB Interrupt Handlers
 365          //   The following functions are called by the USB interrupt jump table.
C51 COMPILER V8.08   SLAVE                                                                 07/25/2020 11:39:40 PAGE 7   

 366          //-----------------------------------------------------------------------------
 367          
 368          // Setup Data Available Interrupt Handler
 369          void ISR_Sudav( void ) interrupt 0
 370          {
 371   1         GotSUD = TRUE;         // Set flag
 372   1         EZUSB_IRQ_CLEAR( );
 373   1         USBIRQ = bmSUDAV;      // Clear SUDAV IRQ
 374   1      }
 375          
 376          // Setup Token Interrupt Handler
 377          void ISR_Sutok( void ) interrupt 0
 378          {
 379   1         EZUSB_IRQ_CLEAR( );
 380   1         USBIRQ = bmSUTOK;      // Clear SUTOK IRQ
 381   1      }
 382          
 383          void ISR_Sof( void ) interrupt 0
 384          {                
 385   1        if(wn_33ms<273){wn_33ms++;}
 386   1        else{wn_33ms=0;}
 387   1         EZUSB_IRQ_CLEAR( );
 388   1         USBIRQ = bmSOF;        // Clear SOF IRQ
 389   1      }
 390          
 391          void ISR_Ures( void ) interrupt 0
 392          {
 393   1         if ( EZUSB_HIGHSPEED( ) )
 394   1         {
 395   2            pConfigDscr = pHighSpeedConfigDscr;
 396   2            pOtherConfigDscr = pFullSpeedConfigDscr;
 397   2         }
 398   1         else
 399   1         {
 400   2            pConfigDscr = pFullSpeedConfigDscr;
 401   2            pOtherConfigDscr = pHighSpeedConfigDscr;
 402   2         }
 403   1         
 404   1         EZUSB_IRQ_CLEAR( );
 405   1         USBIRQ = bmURES;       // Clear URES IRQ
 406   1      }
 407          
 408          void ISR_Susp( void ) interrupt 0
 409          {
 410   1         Sleep = TRUE;
 411   1         EZUSB_IRQ_CLEAR( );
 412   1         USBIRQ = bmSUSP;
 413   1      }
 414          
 415          void ISR_Highspeed( void ) interrupt 0
 416          {
 417   1         if ( EZUSB_HIGHSPEED( ) )
 418   1         {
 419   2            pConfigDscr = pHighSpeedConfigDscr;
 420   2            pOtherConfigDscr = pFullSpeedConfigDscr;
 421   2         }
 422   1         else
 423   1         {
 424   2            pConfigDscr = pFullSpeedConfigDscr;
 425   2            pOtherConfigDscr = pHighSpeedConfigDscr;
 426   2         }
 427   1      
C51 COMPILER V8.08   SLAVE                                                                 07/25/2020 11:39:40 PAGE 8   

 428   1         EZUSB_IRQ_CLEAR( );
 429   1         USBIRQ = bmHSGRANT;
 430   1      }
 431          void ISR_Ep0ack( void ) interrupt 0
 432          {
 433   1      }
 434          void ISR_Stub( void ) interrupt 0
 435          {
 436   1      }
 437          void ISR_Ep0in( void ) interrupt 0
 438          {
 439   1      }
 440          void ISR_Ep0out( void ) interrupt 0
 441          {
 442   1      }
 443          void ISR_Ep1in( void ) interrupt 0
 444          {
 445   1      }
 446          void ISR_Ep1out( void ) interrupt 0
 447          {
 448   1      }
 449          void ISR_Ep2inout( void ) interrupt 0
 450          {
 451   1      }
 452          void ISR_Ep4inout( void ) interrupt 0
 453          {
 454   1      }
 455          void ISR_Ep6inout( void ) interrupt 0
 456          {
 457   1      }
 458          void ISR_Ep8inout( void ) interrupt 0
 459          {
 460   1      }
 461          void ISR_Ibn( void ) interrupt 0
 462          {
 463   1      }
 464          void ISR_Ep0pingnak( void ) interrupt 0
 465          {
 466   1      }
 467          void ISR_Ep1pingnak( void ) interrupt 0
 468          {
 469   1      }
 470          void ISR_Ep2pingnak( void ) interrupt 0
 471          {
 472   1      }
 473          void ISR_Ep4pingnak( void ) interrupt 0
 474          {
 475   1      }
 476          void ISR_Ep6pingnak( void ) interrupt 0
 477          {
 478   1      }
 479          void ISR_Ep8pingnak( void ) interrupt 0
 480          {
 481   1      }
 482          void ISR_Errorlimit( void ) interrupt 0
 483          {
 484   1      }
 485          void ISR_Ep2piderror( void ) interrupt 0
 486          {
 487   1      }
 488          void ISR_Ep4piderror( void ) interrupt 0
 489          {
C51 COMPILER V8.08   SLAVE                                                                 07/25/2020 11:39:40 PAGE 9   

 490   1      }
 491          void ISR_Ep6piderror( void ) interrupt 0
 492          {
 493   1      }
 494          void ISR_Ep8piderror( void ) interrupt 0
 495          {
 496   1      }
 497          void ISR_Ep2pflag( void ) interrupt 0
 498          {
 499   1      }
 500          void ISR_Ep4pflag( void ) interrupt 0
 501          {
 502   1      }
 503          void ISR_Ep6pflag( void ) interrupt 0
 504          {
 505   1      }
 506          void ISR_Ep8pflag( void ) interrupt 0
 507          {
 508   1      }
 509          void ISR_Ep2eflag( void ) interrupt 0
 510          {
 511   1      }
 512          void ISR_Ep4eflag( void ) interrupt 0
 513          {
 514   1      }
 515          void ISR_Ep6eflag( void ) interrupt 0
 516          {
 517   1      }
 518          void ISR_Ep8eflag( void ) interrupt 0
 519          {
 520   1      }
 521          void ISR_Ep2fflag( void ) interrupt 0
 522          {
 523   1      }
 524          void ISR_Ep4fflag( void ) interrupt 0
 525          {
 526   1      }
 527          void ISR_Ep6fflag( void ) interrupt 0
 528          {
 529   1      }
 530          void ISR_Ep8fflag( void ) interrupt 0
 531          {
 532   1      }
 533          void ISR_GpifComplete( void ) interrupt 0
 534          {
 535   1      }
 536          void ISR_GpifWaveform( void ) interrupt 0
 537          {
 538   1      }
 539          
 540          // ...debug LEDs: accessed via movx reads only ( through CPLD )
 541          // it may be worth noting here that the default monitor loads at 0xC000
 542          xdata volatile const BYTE LED0_ON  _at_ 0x8000;
 543          xdata volatile const BYTE LED0_OFF _at_ 0x8100;
 544          xdata volatile const BYTE LED1_ON  _at_ 0x9000;
 545          xdata volatile const BYTE LED1_OFF _at_ 0x9100;
 546          xdata volatile const BYTE LED2_ON  _at_ 0xA000;
 547          xdata volatile const BYTE LED2_OFF _at_ 0xA100;
 548          xdata volatile const BYTE LED3_ON  _at_ 0xB000;
 549          xdata volatile const BYTE LED3_OFF _at_ 0xB100;
 550          // use this global variable when (de)asserting debug LEDs...
 551          BYTE xdata ledX_rdvar = 0x00;
C51 COMPILER V8.08   SLAVE                                                                 07/25/2020 11:39:40 PAGE 10  

 552          BYTE xdata LED_State = 0;
 553          void LED_Off (BYTE LED_Mask)
 554          {
 555   1              if (LED_Mask & bmBIT0)
 556   1              {
 557   2                      ledX_rdvar = LED0_OFF;
 558   2                      LED_State &= ~bmBIT0;
 559   2              }
 560   1              if (LED_Mask & bmBIT1)
 561   1              {
 562   2                      ledX_rdvar = LED1_OFF;
 563   2                      LED_State &= ~bmBIT1;
 564   2              }
 565   1              if (LED_Mask & bmBIT2)
 566   1              {
 567   2                      ledX_rdvar = LED2_OFF;
 568   2                      LED_State &= ~bmBIT2;
 569   2              }
 570   1              if (LED_Mask & bmBIT3)
 571   1              {
 572   2                      ledX_rdvar = LED3_OFF;
 573   2                      LED_State &= ~bmBIT3;
 574   2              }
 575   1      }
 576          
 577          void LED_On (BYTE LED_Mask)
 578          {
 579   1              if (LED_Mask & bmBIT0)
 580   1              {
 581   2                      ledX_rdvar = LED0_ON;
 582   2                      LED_State |= bmBIT0;
 583   2              }
 584   1              if (LED_Mask & bmBIT1)
 585   1              {
 586   2                      ledX_rdvar = LED1_ON;
 587   2                      LED_State |= bmBIT1;
 588   2              }
 589   1              if (LED_Mask & bmBIT2)
 590   1              {
 591   2                      ledX_rdvar = LED2_ON;
 592   2                      LED_State |= bmBIT2;
 593   2              }
 594   1              if (LED_Mask & bmBIT3)
 595   1              {
 596   2                      ledX_rdvar = LED3_ON;
 597   2                      LED_State |= bmBIT3;
 598   2              }
 599   1      }
 600          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    955    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      5    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     13       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
